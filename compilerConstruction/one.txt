Here are the **codes** from your requested Compiler Construction Practicals — **2, 3, 4, 5, 6, and 10 only** — extracted cleanly from your PDF:

---

### ⚙️ **Practical 2 — Lex Programs**

**(a) Print “Hello World”)**

```lex
%{
#include <stdio.h>

int yywrap(void) {
    return 1;
}
%}

%%
.   { printf("Hello, World\n"); }
%%

int main() {
    yylex();
    return 0;
}
```

---

**(b) Recognize Tokens**

```lex
%{
#include <stdio.h>
int yylineno = 1;
void yyerror(const char *s);
%}

%%
[0-9]           { printf("DIGIT: '%s'\n", yytext); }
[a-zA-Z]        { printf("LETTER: '%s'\n", yytext); }
[ \t]+          { printf("WHITESPACE: '%s'\n", yytext); }
\n              { yylineno++; printf("NEWLINE (Line: %d)\n", yylineno); }
.               { printf("OTHER_CHARACTER: '%s'\n", yytext); }
%%

int yywrap(void) { return 1; }

void yyerror(const char *s) {
    fprintf(stderr, "Error at line %d: %s ('%s')\n", yylineno, s, yytext);
}

int main(void) {
    printf("Lexical Analyzer for character categories starting.\n");
    yylex();
    printf("Lexical analysis finished.\n");
    return 0;
}
```

---

**(c) Count Vowels and Consonants**

```lex
%{
#include<stdio.h>
int v=0,c=0;
%}

%%
[aeiouAEIOU] {v++; printf("VOWEL: '%s'\n",yytext);}
[b-df-hj-np-tv-zB-DF-HJ-NP-TV-Z] {c++; printf("CONSONANT: '%s'\n",yytext);}
. {/* Ignore others */}
%%

int yywrap(void){ return 1; }

int main(void){
 printf("Enter text\n");
 yylex();
 printf("Number of Vowels : %d\n",v);
 printf("Number of Consonants : %d\n",c);
 return 0;
}
```

---

**(d) Count Characters, Words & Lines (from file)**

```lex
%{
#include <stdio.h>
int char_count = 0;
int word_count = 0;
int line_count = 0;
%}

%%
[A-Za-z0-9_]+      { word_count++; char_count += yyleng; }
\n                 { line_count++; char_count++; }
[ \t]+             { char_count += yyleng; }
.                  { char_count++; }
%%

int yywrap(void) { return 1; }

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    FILE *fp = fopen(argv[1], "r");
    if (!fp) { perror("Error opening file"); return 1; }

    yyin = fp;
    yylex();
    fclose(fp);

    printf("\nLines : %d\nWords : %d\nCharacters : %d\n", line_count, word_count, char_count);
    return 0;
}
```

---

### ⚙️ **Practical 3 — Lex Programs for File Processing**

(Programs to extract numbers, HTML tags, comments)

Since the PDF didn’t include the explicit Lex code, it only lists tasks:

* Print all numbers from file.
* Print all HTML tags.
* Count comment lines in a C file and copy uncommented code to another file.
  (You can implement using regex patterns like `[0-9]+`, `<[^>]+>`, and `//.*|/\*[^*]*\*/` respectively.)

---

### ⚙️ **Practical 4 — Lexical Analyzer in C**

```c
#include <stdio.h>
#include <string.h>

char *keywords[] = {"int", "float", "char", "if", "else", "while", "for", "do", "return",
"main", "void", "double", "break", "continue"};
int n_keywords = 14;

int isKeyword(const char *text) {
    for (int i = 0; i < n_keywords; ++i) {
        if (strcmp(text, keywords[i]) == 0)
            return 1;
    }
    return 0;
}

int main(int argc, char **argv) {
    FILE *fp;
    char word[50];

    if (argc == 2)
        fp = fopen(argv[1], "r");
    else
        fp = stdin;

    while (fscanf(fp, "%s", word) != EOF) {
        if (isKeyword(word))
            printf("%-16s Keyword\n", word);
        else if (isalpha(word[0]) || word[0]=='_')
            printf("%-16s Identifier\n", word);
        else if (isdigit(word[0]))
            printf("%-16s Number\n", word);
        else
            printf("%-16s Unknown\n", word);
    }

    if (fp != stdin)
        fclose(fp);
    return 0;
}
```

---

### ⚙️ **Practical 5 — Identify Comments & Identifiers**

**(a) Comment Check**

```c
#include <stdio.h>
#include <string.h>

int main() {
    char line[200];
    printf("Enter a line of code: ");
    fgets(line, sizeof(line), stdin);
    line[strcspn(line, "\n")] = 0;

    if (line[0] == '/' && line[1] == '/')
        printf("Single-line comment.\n");
    else if (line[0] == '/' && line[1] == '*') {
        int len = strlen(line);
        if (len >= 2 && line[len - 2] == '*' && line[len - 1] == '/')
            printf("Multi-line comment.\n");
        else
            printf("Start of multi-line comment.\n");
    } else
        printf("Not a comment.\n");
    return 0;
}
```

**(b) Valid Identifier**

```c
#include <stdio.h>
#include <ctype.h>
#include <string.h>

int isValidIdentifier(char str[]) {
    if (str[0] == '\0' || isdigit(str[0])) return 0;
    for (int i = 0; str[i] != '\0'; i++)
        if (!(isalnum(str[i]) || str[i] == '_'))
            return 0;
    return 1;
}

int main() {
    char str[100];
    printf("Enter an identifier: ");
    scanf("%s", str);
    if (isValidIdentifier(str))
        printf("'%s' is a valid identifier.\n", str);
    else
        printf("'%s' is NOT a valid identifier.\n", str);
    return 0;
}
```

---

### ⚙️ **Practical 6 — Lexical Analyzer for Operators**

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool isArithmeticOperator(char *op) {
    return (!strcmp(op,"+") || !strcmp(op,"-") || !strcmp(op,"*") ||
            !strcmp(op,"/") || !strcmp(op,"%"));
}

bool isRelationalOperator(char *op) {
    return (!strcmp(op,"==") || !strcmp(op,"!=") || !strcmp(op,">") ||
            !strcmp(op,"<") || !strcmp(op,">=") || !strcmp(op,"<="));
}

bool isLogicalOperator(char *op) {
    return (!strcmp(op,"&&") || !strcmp(op,"||") || !strcmp(op,"!"));
}

bool isAssignmentOperator(char *op) {
    return (!strcmp(op,"=") || !strcmp(op,"+=") || !strcmp(op,"-=") ||
            !strcmp(op,"*=") || !strcmp(op,"/=") || !strcmp(op,"%="));
}

bool isBitwiseOperator(char *op) {
    return (!strcmp(op,"&") || !strcmp(op,"|") || !strcmp(op,"^") ||
            !strcmp(op,"~") || !strcmp(op,"<<") || !strcmp(op,">>"));
}

int main() {
    char op[5];
    printf("Enter an operator: ");
    scanf("%s", op);

    if (isArithmeticOperator(op)) printf("%s is Arithmetic Operator\n", op);
    else if (isRelationalOperator(op)) printf("%s is Relational Operator\n", op);
    else if (isLogicalOperator(op)) printf("%s is Logical Operator\n", op);
    else if (isAssignmentOperator(op)) printf("%s is Assignment Operator\n", op);
    else if (isBitwiseOperator(op)) printf("%s is Bitwise Operator\n", op);
    else printf("%s is not a valid operator\n", op);

    return 0;
}
```

---

### ⚙️ **Practical 10 — YACC Program for Valid Identifier**

**Lex File:**

```lex
%{
#include "y.tab.h"
%}

%%
[a-zA-Z_][a-zA-Z_0-9]*    return letter;
[0-9]                     return digit;
.                         return yytext[0];
\n                        return 0;
%%

int yywrap() { return 1; }
```

**Yacc File:**

```yacc
%{
#include <stdio.h>
int valid = 1;
%}

%token digit letter

%%
start : letter s ;
s     : letter s
      | digit s
      | /* empty */ ;
%%

int yyerror() {
    printf("\nIt's not an identifier!\n");
    valid = 0;
    return 0;
}

int main() {
    printf("\nEnter a name to test for identifier: ");
    yyparse();
    if (valid)
        printf("\nIt is a valid identifier!\n");
    return 0;
}
```

---

Would you like me to **export these six practicals into separate `.c` / `.l` / `.y` files** in a ZIP for easier compilation and submission?
